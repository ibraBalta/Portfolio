<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projet DBOmics | Ibrahim Balta</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <header id="header">
        <div class="logo"><a href="index.html">IBRAHIM<span class="dot">.</span></a></div>
        <nav>
            <ul class="nav-links">
                <li><a href="index.html" class="btn-nav">← Retour Portfolio</a></li>
            </ul>
            
            <div class="burger">
                <div class="line1"></div>
                <div class="line2"></div>
                <div class="line3"></div>
            </div>
        </nav>
    </header>

    <section class="project-hero">
        <div class="hero-container">
            <span class="project-tag">Stage S4 • Université de Haute-Alsace</span>
            <h1 class="glitch-text">DBOmics</h1>
            <p class="project-subtitle">Application interactive de visualisation de données métabolomiques</p>
            <div class="tech-badges">
                <span class="badge">R Shiny</span>
                <span class="badge">PostgreSQL</span>
                <span class="badge">Sécurité</span>
                <span class="badge">DataViz</span>
            </div>
        </div>
    </section>

    <div class="reading-container">
        
        <div class="toc-card">
            <h3>Sommaire du rapport</h3>
            <ul>
                <li><a href="#section-dev">01. Réaliser un développement d’application (UE 4.1)</a></li>
                <li><a href="#section-data">02. Gérer des données de l’information (UE 4.4)</a></li>
            </ul>
        </div>

        <main class="article-content">
            
            <p class="intro-text">Du 19 mai au 11 juillet 2025, j’ai effectué mon stage de deuxième année de BUT Informatique au sein du projet <strong>DBOmics</strong>, une application web développée à l’Université de Haute-Alsace. Ce projet avait pour ambition de fournir un outil interactif et accessible pour explorer des données métabolomiques complexes, issues d’expériences scientifiques sur différents organismes vivants.</p>
            
            <p>L’application DBOmics permet aux utilisateurs d’interroger et de visualiser, via une interface intuitive, des résultats d’analyses métaboliques selon plusieurs filtres : métabolites étudiés, modalités expérimentales, compartiments biologiques, espèces ou organismes. Elle intègre une heatmap interactive générée dynamiquement à partir d’une base de données PostgreSQL, ainsi qu’un système d’authentification complet, permettant de différencier les droits d’accès selon les rôles des utilisateurs (public, utilisateur enregistré, administrateur). Mon rôle pendant ce stage a été de contribuer au développement applicatif de DBOmics, en particulier sur les fonctionnalités d’authentification, de gestion des utilisateurs, de sécurité et de visualisation des données.</p>

            <hr class="divider">

            <h2 id="section-dev">Réaliser un développement d’application (UE 4.1)</h2>

            <h3>Authentification sécurisée et réinitialisation de mot de passe</h3>

            <p>Parmi les compétences mobilisées lors de mon stage, la première qui se démarque est celle de réaliser un développement d’application. J’ai été directement impliqué dans l’écriture de plusieurs modules complets en R Shiny, notamment pour la partie authentification des utilisateurs, la gestion sécurisée des comptes, et la mise en place d’une fonctionnalité de réinitialisation de mot de passe par email. Cette dernière fonctionnalité, que j’ai conçue et développée de bout en bout, constitue un exemple représentatif de la compétence UE4.1.</p>
            
            <p>Un des besoins exprimés par ma tutrice de stage était de permettre aux utilisateurs qui auraient oublié leur mot de passe de pouvoir en définir un nouveau, de manière simple mais sécurisée. Pour cela, j’ai mis en place un système basé sur l’envoi d’un lien temporaire contenant un token sécurisé, qui permet d’ouvrir un formulaire de réinitialisation, après vérification dans la base de données.</p>
            
            <p>Cette tâche m’a amené à combiner plusieurs briques logicielles : la génération de jetons uniques avec <code>uuid</code>, leur hachage avec l’algorithme SHA256 (via <code>digest</code>), l’envoi d’e-mails avec <code>blastula</code>, et l’interfaçage avec la base PostgreSQL pour la gestion des tokens et des utilisateurs. J’ai également dû gérer la notion d’expiration du lien, la validation des nouveaux mots de passe selon des critères de robustesse (longueur, complexité, caractères spéciaux), ainsi que le hachage final du mot de passe avec <code>scrypt</code>.</p>

            <p>Ci-dessous un extrait du code qui génère le lien sécurisé et envoie l’e-mail de réinitialisation :</p>
            
            <pre><code># Génération d'un token unique pour la réinitialisation
token <- uuid::UUIDgenerate(use.time = FALSE)
# Hachage du token pour stockage sécurisé
token_hash <- digest(token, algo = "sha256")
# Définition de la date d'expiration 10 minutes plus tard
expires_at <- format(Sys.time() + lubridate::minutes(10), "%Y-%m-%d %H:%M:%S")

# Insertion du token haché dans la table password_reset
dbExecute(con, "INSERT INTO password_reset (email, token_hash, expires_at) VALUES ($1, $2, $3)",
          params = list(email, token_hash, expires_at))

# Construction de l'URL de réinitialisation à envoyer par email
reset_url <- paste0("http://127.0.0.1:6995/?token=", token)

mail <- blastula::compose_email(
  body = blastula::md(glue::glue("
  You requested a password reset.

  Click the link below to choose a new password:

  [{reset_url}]({reset_url})

  This link will expire in 10 minutes.
  "))
)

# Envoi de l'email avec les identifiants SMTP sécurisés
blastula::smtp_send(
  email         = mail,
  from          = "dbomics@gmail.com",
  to            = email,
  subject       = "Password Reset Request",
  credentials = blastula::creds_key("gmail")
)</code></pre>
            <figcaption>Figure 1 – Génération du lien sécurisé de réinitialisation : création d’un token unique, stockage haché, et envoi d’un lien temporaire par e-mail à l’utilisateur.</figcaption>

            <p>Ce code montre comment j’ai combiné la logique d’envoi de mail, la sécurité (via hachage) et la gestion d’expiration. Il s’agit d’une fonctionnalité réelle, utilisée dans l’application, et donc soumise à des contraintes de fiabilité et de robustesse. Cela m’a demandé de comprendre le fonctionnement des jetons, de manipuler les chaînes de requêtes, et d’écrire une logique de vérification du token lors de l’ouverture du lien.</p>
            
            <p>Une fois le lien reçu, l’utilisateur peut saisir un nouveau mot de passe. Voici un extrait du code côté serveur qui gère la validation du lien et le formulaire :</p>
            
            <pre><code>observe({
  qs <- parseQueryString(session$clientData$url_search)
  if (!is.null(qs$token)) {
    token <- qs$token
    token_hash <- digest(token, algo = "sha256")

    # Recherche du token haché valide et non expiré
    res <- dbGetQuery(con, "
      SELECT email FROM password_reset
      WHERE token_hash = $1 AND expires_at > NOW() AND used = FALSE
      ORDER BY created_at DESC LIMIT 1", params = list(token_hash))

    if (nrow(res) > 0) {
      # Stockage de l'e-mail pour le processus de réinitialisation
      session$userData$reset_email <- res$email[1]
      session$userData$reset_token_hash <- token_hash
      showModal(...)  # Affichage du formulaire de nouveau mot de passe
    } else {
      # Notification d’erreur si le lien est invalide ou expiré
      showNotification("Invalid or expired link.", type = "error")
    }
  }
})</code></pre>
            <figcaption>Figure 2 – Validation du lien de réinitialisation côté serveur : vérification que le token n’est pas expiré ou déjà utilisé avant d’afficher le formulaire.</figcaption>

            <p>Ce traitement garantit que seul un lien valide, non expiré et non encore utilisé peut ouvrir le formulaire. Cette logique correspond parfaitement aux attentes de l’UE4.1 : j’ai ici conçu une interface réactive, connecté mon application à une base relationnelle, intégré une logique métier complète avec gestion des erreurs, et respecté les bonnes pratiques en matière de sécurité. Cela a nécessité un travail de recherche, de test et d’ajustement, notamment pour la syntaxe SQL, les horodatages en UTC, ou encore le bon encodage des e-mails envoyés.</p>
            
            <p>Cette fonctionnalité m’a permis d’approfondir mes compétences sur des sujets concrets tels que l’authentification, la sécurité applicative, les formulaires réactifs, et la communication avec une base PostgreSQL. Elle illustre à la fois ma capacité à comprendre un besoin fonctionnel, à proposer une solution technique adaptée, et à la mettre en œuvre dans un environnement réel.</p>

            <figure>
                <img src="assets/schema_mdp_oublie.png" alt="Schéma du fonctionnement du système de mot de passe oublié">
                <figcaption>
                    Figure 3 – Schéma du processus de réinitialisation de mot de passe :  
                    ce schéma illustre les différentes étapes du système, en distinguant :
                    <span style="color: #ffd700; font-weight: bold;">les actions utilisateur</span>, 
                    <span style="color: #ff8c00; font-weight: bold;">les vérifications et contrôles</span>, 
                    et <span style="color: #00d4ff; font-weight: bold;">les traitements applicatifs</span>.
                </figcaption>
            </figure>

            <p>Ce schéma représente de manière structurée le fonctionnement du système de réinitialisation de mot de passe. Il met en évidence les interactions entre les différentes couches de l’application : interface utilisateur, logique serveur et base de données. Il distingue également les étapes critiques comme la génération du token sécurisé, l’envoi de l’e-mail, la vérification du lien et la mise à jour du mot de passe.</p>
            
            <p>Au-delà de l’implémentation, cette modélisation synthétise les différentes étapes du processus de réinitialisation et met en évidence les points de vigilance liés à la sécurité applicative, comme la gestion de l’expiration des liens, la non-réutilisation des tokens ou encore la validation des nouveaux mots de passe. Elle permet une compréhension rapide du flux applicatif et des responsabilités de chaque composant du système.</p>
            
            <p>La capacité à représenter, documenter et expliquer une solution technique est essentielle dans le cadre d’un développement structuré. Elle démontre ici une démarche rigoureuse, conforme aux attendus de l’UE 4.1, en intégrant à la fois la conception fonctionnelle, la sécurité, et la transmissibilité du code dans un environnement collaboratif.</p>

            <h3>Visualisation dynamique : développement de la heatmap interactive</h3>
            <p>Outre la partie authentification, j’ai également contribué à la visualisation dynamique des résultats expérimentaux via une heatmap interactive. Ce composant constitue le cœur fonctionnel de l’application DBOmics, car il permet à l’utilisateur d’explorer les différences d’intensité de métabolites entre conditions expérimentales, de manière visuelle et immédiate.</p>
            
            <p>La heatmap est construite à partir de données filtrées en fonction des sélections de l'utilisateur (métabolite, espèce, compartiment, modalité…). Ces données sont ensuite traitées pour générer une grille, où chaque case représente un niveau de métabolite pour un triplet biologique donné, et est colorée selon un <code>log2(Fold Change)</code>. Ce système visuel permet de repérer rapidement les variations marquées.</p>
            
            <p>Le développement de cette fonctionnalité m’a demandé de manipuler à la fois des structures de données complexes (avec jointures dynamiques), des fonctions de mise en forme pour le composant <code>plotly</code>, et des interfaces utilisateurs réactives. Voici un extrait du code responsable de l'affichage de la heatmap :</p>
            
            <pre><code>plot_ly(
  data        = df,
  x           = ~Niveau_label,
  y           = ~y_label,
  z           = ~log2(Fold_Change),
  type        = "heatmap",
  # Palette de couleurs personnalisée pour les valeurs extrêmes
  colorscale = list(c(0, "blue"), c(0.5, "white"), c(1, "red")),
  # Définition des seuils minimal, médian et maximal
  zmin        = log2(0.17), zmid = 0, zmax = log2(6),
  colorbar    = list(
    title     = "Fold Change",
    tickvals  = c(log2(0.17), log2(0.415), 0, log2(2.5), log2(6)),
    ticktext  = c("0.17–", "0.415", "1", "2.5", "6+")
  ),
  # Données supplémentaires pour l’affichage au clic
  customdata = ~info_click,
  hoverinfo  = "text",
  text        = ~hover_text,
  source      = "hm"
)</code></pre>
            <figcaption>Figure 4 – Affichage de la heatmap avec Plotly : visualisation des variations métaboliques par couleur, en fonction des paramètres expérimentaux sélectionnés.</figcaption>

            <p>Ce code montre la création d’une heatmap colorée avec <code>plotly</code>, en utilisant des seuils personnalisés pour les couleurs, et en intégrant des informations supplémentaires accessibles au survol (tooltip). Une difficulté a été de rendre la taille de la heatmap dynamique en fonction du nombre de lignes et de colonnes, ce que j’ai géré avec un système de calcul de dimensions (<code>width_px</code> / <code>height_px</code>), afin d’assurer une expérience utilisateur fluide quelle que soit la sélection.</p>
            
            <p>J’ai également ajouté une logique permettant d’afficher des informations détaillées au clic sur une case, avec la description du projet expérimental, les espèces étudiées, la modalité, et un lien vers la publication (DOI). Cela a nécessité une mise en cohérence entre la base de données, le traitement des filtres, et l’interface graphique, ce qui m’a permis d’enrichir ma compréhension de la programmation réactive dans R Shiny.</p>

            <div class="highlight-box">
                <strong>Bilan - UE 4.1 :</strong> Au cours de ce stage, j’ai pu expérimenter concrètement ce que signifie concevoir, développer et maintenir une application web réelle, avec des enjeux fonctionnels, des utilisateurs finaux, et des contraintes de sécurité et de fiabilité. Que ce soit par le développement de la fonction de réinitialisation de mot de passe ou de la heatmap interactive, j’ai mobilisé et approfondi de nombreuses compétences acquises en BUT Informatique, notamment en R, SQL, et en conception d’interface.
                <br><br>
                J’ai aussi appris à travailler avec une base de données PostgreSQL complexe, à assurer la sécurité des données sensibles (mots de passe, tokens), à gérer la logique de rôles et d’accès différenciés, et à produire une visualisation interactive claire et efficace. Cette expérience m’a permis de prendre confiance en mes capacités de développeur et de mieux comprendre l’importance d’une architecture claire, modulaire et documentée.
            </div>

            <hr class="divider">

            <h2 id="section-data">Gérer des données de l’information (UE 4.4)</h2>

            <h3>Traitement, structuration et filtrage des données expérimentales</h3>
            <p>Une deuxième compétence que j’ai mobilisée de manière centrale lors de mon stage est la capacité à gérer des données de l’information, notamment dans le cadre du traitement des données expérimentales utilisées dans DBOmics. L’application repose sur une base de données PostgreSQL contenant des résultats métabolomiques bruts issus d’analyses scientifiques, avec des centaines d’expériences, métabolites et conditions biologiques différentes. Mon rôle a été de préparer, structurer et transformer ces données pour qu’elles puissent être affichées correctement dans l’interface, notamment dans la heatmap.</p>
            
            <p>Le traitement de ces données implique plusieurs étapes clés : la lecture des tables PostgreSQL, la normalisation des noms de colonnes, la fusion de tables, l’ajout d’indicateurs calculés comme les fold-changes ou les niveaux de référence, puis le filtrage dynamique en fonction des sélections utilisateur. Voici un extrait représentatif de cette préparation :</p>
            
            <pre><code>df_pre <- dbReadTable(con, "Glucose_test")

# Renommage pour harmoniser les noms dans l’app
df_prep <- dplyr::rename(
  df_pre,
  Projet        = Nom_Projet,
  Description   = Description,
  Organisme     = Type_Organisme,
  Espece        = Nom_Espece,
  Compartiment  = Compartiment,
  Modalite      = Nom_Modalite,
  Niveau        = Valeur,
  Metabolite    = Nom_commun,
  Fold_Change   = Fold_Change,
  Public        = Public,
  Reference     = Reference
)</code></pre>
            <figcaption>Figure 5 – Préparation initiale des données PostgreSQL : renommage des colonnes pour normalisation et harmonisation avec l’interface de l’application.</figcaption>

            <h3>Jointures et calculs de référence</h3>
            <p>Après cette étape de renommage, j’ai mis en place une logique permettant d’identifier les niveaux de référence (valeurs avec Fold Change = 1), de les isoler, et de les rattacher à chaque ligne expérimentale afin de calculer une étiquette lisible et informative. Cela a été réalisé via une jointure conditionnelle :</p>
            
            <pre><code># On récupère les lignes qui servent de référence
temp_filtered <- dplyr::filter(df_prep, Fold_Change == 1)
temp_selected <- dplyr::select(temp_filtered, Organisme, Espece, Compartiment, Metabolite, Niveau)
ref_levels    <- dplyr::rename(temp_selected, Niveau_ref = Niveau)

# Jointure avec les autres données pour ajouter la colonne Niveau_ref
joined_df <- left_join(df_prep, ref_levels,
                        by = c("Organisme", "Espece", "Compartiment", "Metabolite"))

# Ajout d’un label combiné pour affichage dans la heatmap
with_label <- mutate(joined_df,
                      Niveau_label = paste(Modalite, Niveau, "/", Niveau_ref))

# On exclut les lignes de référence pour ne garder que les comparaisons
df_all <- filter(with_label, Fold_Change != 1)</code></pre>
            <figcaption>Figure 6 – Ajout des niveaux de référence et étiquetage : jointure conditionnelle pour calculer les niveaux de référence et créer un label informatif.</figcaption>

            <h3>Filtrage dynamique et réactivité dans Shiny</h3>
            <p>Dans le frontend, j’ai participé à la mise en œuvre d’une interface filtrable réactive qui permet à l’utilisateur de raffiner sa sélection à chaque étape, en mettant à jour dynamiquement les options des filtres restants. Cela a nécessité une bonne compréhension de la programmation réactive dans Shiny et de la gestion des dépendances entre filtres.</p>
            
            <p>Voici un exemple de filtrage dynamique en fonction des sélections :</p>
            
            <pre><code>observeEvent(input$metabolite, {
  df_f <- dplyr::filter(df_all_user(), Metabolite == input$metabolite)
  updateCheckboxGroupInput(session, "organisme",    choices = sort(unique(df_f$Organisme)))
  updateCheckboxGroupInput(session, "espece",       choices = sort(unique(df_f$Espece)))
  updateCheckboxGroupInput(session, "compartiment", choices = sort(unique(df_f$Compartiment)))
  updateCheckboxGroupInput(session, "modalite",     choices = sort(unique(df_f$Modalite)))
})</code></pre>
            <figcaption>Figure 7 – Mise à jour des filtres dynamiques dans Shiny : ajustement des options de filtrage en fonction du métabolite sélectionné, pour une interface réactive.</figcaption>

            <div class="highlight-box">
                <strong>Bilan - UE 4.4 :</strong> Cette compétence a été omniprésente dans mon stage, car toute l’application repose sur la qualité et la cohérence des données affichées. J’ai appris à manipuler de véritables jeux de données expérimentales, à automatiser leur traitement, à anticiper les erreurs de structure ou d’interprétation, et à rendre ces données accessibles via une interface filtrable.
                <br><br>
                J’ai aussi découvert l’importance de la clarté des noms, de la documentation, et du découpage logique des étapes de transformation. Ce travail préparatoire, souvent invisible pour l’utilisateur final, est pourtant fondamental pour que l’application soit fonctionnelle, fiable et agréable à utiliser. Grâce à cette expérience, je me sens aujourd’hui beaucoup plus à l’aise pour préparer, nettoyer, enrichir et exploiter des données dans un contexte réel, ce qui correspond pleinement aux attendus de l’UE4.4.
            </div>

            <div class="navigation-footer">
                <a href="index.html#projects" class="btn-return">
                    <span class="arrow">←</span> Retour à la liste des projets
                </a>
            </div>

        </main>
    </div>

    <footer>
        <p>&copy; 2025 Ibrahim Balta. <a href="#">Haut de page ↑</a></p>
    </footer>

    <script src="script.js"></script>
</body>
</html>